#ifndef USER_H
#define USER_H

#include <can-18F4580.c>
/* Error Code Start */
#define	CB_OK								0

#define CB_FS_OPEN_FILE_ERROR				-1
#define CB_FS_SEND_RESULT_ERROR				-2
#define CB_FS_SIZE_EOF_NOT_FOUND			-3
#define CB_FS_READ_ERROR					-4

#define CB_BB_OPEN_ERROR_OPEN_PORT			-5
#define CB_BB_OPEN_VERSION_INCOMPATIBLE		-6
#define CB_BB_OPEN_DRIVER_INCOMPATIBLE		-7
#define CB_BB_OPEN_DEVICEIOCONTROL_FAIL		-8
#define CB_BB_CLOSE_BYTEBLASTER_NOT_OPEN	-9
#define CB_BB_FLUSH_ERROR					-10
#define CB_BB_VERIFY_BYTEBLASTER_NOT_FOUND	-11
#define CB_BB_LPTREAD_ERROR					-12
#define CB_BB_LPTWRITE_ERROR				-13

#define CB_PS_CONF_NSTATUS_LOW				-14
#define CB_PS_CONF_CONFDONE_LOW				-15
#define CB_PS_INIT_NSTATUS_LOW				-16
#define CB_PS_INIT_CONFDONE_LOW				-17

#define CB_AS_VERIFY_FAIL					-18
#define CB_AS_UNSUPPORTED_DEVICE			-19
#define CB_AS_WRONG_RPD_FILE				-20

#define CB_INVALID_NUMBER_OF_ARGUMENTS		-21
#define CB_INVALID_COMMAND					-22
#define CB_INVALID_EPCS_DENSITY				-23

#define EPCS_DENSITY						16


//////////Variaveis da inteface CAN///////////////////////////
int32 can_rx_id = 0;
int can_packet_rx[8];
int can_rx_len;
int1 can_data_ack=0;

struct rx_stat rxstat;
int32 can_tx_id_L=1;
int32 can_tx_id_H=2;
int32 can_tx_id_end=255;
int1 tx_rtr=0, tx_rtr_end=1;
int1 tx_ext=0;
int tx_len=8;
int tx_pri=3;
int1 can_flag_tx_L=0;
////////////////////////////////////////////////////////////////////

//////////////Variaveis de controle/////////////////////////////////
int1 WDT_RESET_FAULT = false;  //se houve falta (true) ou n√£o (false)
int1 FPGA_REQ_RECONFIG = false; //inicia (true) ou n√£o (false) a reconfigura√ß√£o
int FPGA_PACKET_BLOCKS = 0; //controle para os dois pacotes de 64 bits que formam o pacote de 128 bits do AES, √© zerado ao fim da descriptografia
int1 BUFFER_READY = false; // buffer que armazena os 256 bits de dados por p√°gina
int1 END_CONFIG = false;
int PACKET_ARRIVE = false; //Indica a chegada de um pacote de bitstream via
int BAL_BYTE = 0;
int1 BAL_ACTIVE = false;
const int RESP_ACK_RECEIVE_DATA = 0x35;
const int DATA_EXPERIMENT = 0x36;
const int32 CAN_TX_ID_ACK = 0x01;
const int32 CAN_TX_ID_RES_EXP = 0x02;
////////////////////////////////VARIAVEIS DE PROCESSAMENTO///////////////////////////////////////////

//Vetor de dados de pagina√ß√£o
int DATA_PAGE[256] = {0x00}; //Armazena os dados descritografados a serem gravados em uma p√°gina
int DATA_PAGE_READ[256] = {0x00}; //Armazena os dados lidos da memoria

//endereÁamento m·ximo da memoria 
int32 ADDR_MEM = 0;
//chave de descriptografia
const char DECODE_KEY[]= {0x13,0x11,0x1D,0x7F,0xE3,0x94,0x4A,0x17,0xF3,0x07,0xA7,0x8B,0x4D,0x2B,0x30,0xC5};
//Variavel de teste de p√°gina
unsigned char test_page[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x6a,0xd6,0xff,0x7f,0x00,0x50,0x7e,0x1e,0x00,0x6a,0xd6,0xff,0x7f,0x00,0x50,0x7e,0x1e,0x00,0x6a,0xd6,0xff,0x7f,0x00,0x50,0x7e,0x1e,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x10,0x45,0x54,0x51,0x34,0x75,0x57,0x33,0x35,0x53,0x77,0x75,0x56,0x36,0x65,0x53,0x33,0x25,0x52,0x22,0x25,0x52,0x22,0x25,0x53,0x32,0x35,0xd2,0xe3,0x75,0xce,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x51,0x11,0x15,0x15};

unsigned char EXPERIMENT_RESULT = 0;
/* Error Code END  */
#endif
